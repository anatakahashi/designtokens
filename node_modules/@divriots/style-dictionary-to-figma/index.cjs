'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function markTokenset(obj) {
  const _obj = { ...obj };
  Object.keys(_obj).forEach(key => {
    if (typeof _obj[key] === 'object') {
      const nestedObj =  (_obj[key]);
      Object.keys(nestedObj).forEach(nestedKey => {
        if (nestedKey === 'tokenset') {
          const tokenset =  (nestedObj[nestedKey]);
          if (typeof _obj[tokenset] !== 'object') {
            _obj[tokenset] = {};
          }
           (_obj[tokenset])[key] = nestedObj;
          delete ( (_obj[key])[nestedKey]);
          delete _obj[key];
        }
      });
    }
  });
  return _obj;
}

function trimName(obj) {
  const newObj = { ...obj };
  Object.keys(newObj).forEach(key => {
    if (key === 'name') {
      delete newObj[key];
    } else if (typeof newObj[key] === 'object') {
      newObj[key] = trimName( (newObj[key]));
    }
  });
  return newObj;
}

function trimValue(obj) {
  const newObj = { ...obj };
  Object.keys(newObj).forEach(key => {
    if (key === 'value') {
      const val =  (newObj[key]);
      const reg = /^\{(.*)\}$/g;
      const matches = reg.exec(val);
      if (matches && matches[1]) {
        newObj[key] = val.replace('.value', '');
      }
    } else if (typeof newObj[key] === 'object') {
      newObj[key] = trimValue( (newObj[key]));
    }
  });
  return newObj;
}

function useRefValue(obj) {
  const newObj = { ...obj };
  Object.keys(newObj).forEach(key => {
    if (key === 'original') {
      newObj.value =  (newObj[key]).value;
    } else if (typeof newObj[key] === 'object') {
      newObj[key] = useRefValue( (newObj[key]));
    }
  });
  return newObj;
}

function styleDictionaryToFigma(obj) {
  return markTokenset(trimName(useRefValue(trimValue(obj))));
}

exports["default"] = styleDictionaryToFigma;
exports.markTokenset = markTokenset;
exports.trimName = trimName;
exports.trimValue = trimValue;
exports.useRefValue = useRefValue;
